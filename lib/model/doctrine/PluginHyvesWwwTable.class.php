<?php

/**
 * PluginHyvesWwwTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PluginHyvesWwwTable extends myDoctrineTable implements iSocialMedia
{
  const CLIENT_NAME = 'hyves';

  /**
   * Returns an instance of this class.
   *
   * @return object PluginHyvesWwwTable
   */
  public static function getInstance()
  {
    return Doctrine_Core::getTable('PluginHyvesWww');
  }

  /* (non-PHPdoc)
	 * @see iSocialMedia::getLatestFetchedId()
	 */
  public function getLatestFetchedId($excludeId = null)
  {
    $query = $this->createQuery()->select('www_id')->orderBy('created_at DESC');
    
    if ( !is_null($excludeId) ) {
      $query->addWhere('www_id != ?', $excludeId);
    }
    
    return $query->fetchOne(array(), Doctrine::HYDRATE_SINGLE_SCALAR);
  }

  /* (non-PHPdoc)
	 * @see iSocialMedia::sync()
	 */
  public function sync($refreshTime = 600, $excludeId = null)
  {
    $last_fetch_table = Doctrine_Core::getTable('SocialMediaLastFetch');
    /* @var $last_fetch_table SocialMediaLastFetchTable */
    
    $query_sha1 = sha1('wwws.getByUser');
    
    if ( $last_fetch_table->getLastFetchTimeForClient(self::CLIENT_NAME, 'HyvesWww', $query_sha1) + $refreshTime < time() ) {
      $since_id = $this->getLatestFetchedId($excludeId);
      $parameters = $since_id ? array(
        'since_id' => $since_id
      ) : array();
      
      $client = new Hyves();
      
      if ( !$client->isConnected() ) {
        return false;
      }
      
      // get www's
      $receivedWwws = array();
      try {
        $user = Doctrine_Core::getTable('HyvesUser')->getLoggedin();
        
        if ( $user ) {
          $response = $client->get('', array(
            'userid' => $user->getUserId(), 
            'ha_method' => 'wwws.getByUser'
          ));
          $xml = new DOMDocument();
          $xml->loadXML($response['body']);
          
          $xpath = new DOMXPath($xml);
          $receivedWwws = $xpath->query('//wwws_getByUser_result/www');
        }
      } catch (Exception $e) {
        return false;
      }
      
      $count = 0;
      foreach ($receivedWwws as $recievedWww) {
        $www = new HyvesWww();
        $www->fromDOMElement($recievedWww);
        $www->setRaw($xml->saveXml($recievedWww));
        if ( $excludeId && $excludeId == $www->getWwwId() ) {
          continue;
        }
        try {
          $www->save();
        } catch (Doctrine_Exception $e) {
          if ( $e->getPortableCode() !== Doctrine_Core::ERR_ALREADY_EXISTS ) {
            throw $e;
          }
          continue;
        }
        $count++;
      }
      
      $last_fetch_table->updateLastFetchTimeForClient(self::CLIENT_NAME, 'HyvesWww', $query_sha1, $count);
      
      return $count;
    }
    
    return false;
  }

  /* (non-PHPdoc)
	 * @see iSocialMedia::send()
	 */
  public function send($message, StatusUpdate $statusUpdate = null)
  {
    // get client
    $client = new Hyves();
    
    if ( !$client->isConnected() ) {
      throw new Exception(sprintf('Not connected to Hyves in %s.', __CLASS__));
    }
    
    // send message with the API
    $response = $client->get('', array(
      'ha_method' => 'wwws.create', 
      'emotion' => $message, 
      'visibility' => 'default'
    ));
    
    try {
      // process response
      $xml = new DOMDocument();
      $xml->loadXML($response['body']);
      $xpath = new DOMXPath($xml);
      $nodeList = $xpath->query('//wwws_create_result/www[1]');
      if ( $nodeList->length != 1 ) {
        throw new Exception('unknown response received');
      }
      $recievedWww = $nodeList->item(0);
      
      // create HyvesWww
      $www = new HyvesWww();
      $www->fromDOMElement($recievedWww);
      $www->setRaw($xml->saveXml($recievedWww));
      $www->setStatusUpdate($statusUpdate);
      if ( !$www->getWwwId() ) {
        throw new Exception('wwwid cannot be extracted from response');
      }
      $www->save();
      
      // sync wwws, this makes sure that messages send from outside the cms are cached in the database  
      // the sync always checks the latest inserted tweet, exclude the just created www
      $this->sync(0, $www->getWwwId());
      
      return $www;
    } catch (Exception $e) {
      throw new Exception(sprintf('Cannot process API response in %s: %s.', __CLASS__, $e->getMessage()));
    }
  }
}