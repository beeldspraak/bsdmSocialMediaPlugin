<?php

/**
 * PluginTwitterTweetTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PluginTwitterTweetTable extends myDoctrineTable implements iSocialMedia
{
  const CLIENT_NAME = 'twitter';
  const CLIENT_QUERY = 'statuses/user_timeline.json';

  /**
   * Returns an instance of this class.
   *
   * @return object PluginTwitterTweetTable
   */
  public static function getInstance()
  {
    return Doctrine_Core::getTable('PluginTwitterTweet');
  }

  /**
   * Get the id of the last fetched tweet
   *
   * @param integer $excludeId id of the message to exclude
   * @return integer
   */
  public function getLatestFetchedId($excludeId = null)
  {
    $query = $this->createQuery()->select('tweet_id')->orderBy('created_at DESC');
    
    if ( !is_null($excludeId) ) {
      $query->addWhere('tweet_id != ?', $excludeId);
    }
    
    return $query->fetchOne(array(), Doctrine::HYDRATE_SINGLE_SCALAR);
  }

  /**
   * Sync tweets from Twitter and save them to the database
   *
   * @param integer $excludeId id of the message to exclude
   * @return void
   */
  public function sync($refreshTime = 600, $excludeId = null)
  {
    $last_fetch_table = Doctrine_Core::getTable('SocialMediaLastFetch');
    /* @var $last_fetch_table SocialMediaLastFetchTable */
    
    $query_sha1 = sha1(self::CLIENT_QUERY);
    
    if ( $last_fetch_table->getLastFetchTimeForClient(self::CLIENT_NAME, 'TwitterTweet', $query_sha1) + $refreshTime < time() ) {
      $since_id = $this->getLatestFetchedId($excludeId);
      $parameters = $since_id ? array(
        'since_id' => $since_id
      ) : array();
      
      $client = new Twitter();
      
      if ( !$client->isConnected() ) {
        return false;
      
   //throw new Exception('Not connected to Twitter.');
      }
      
      // get user_timeline tweets
      try {
        $response = $client->get(self::CLIENT_QUERY, $parameters);
        $recievedTweets = json_decode($response['body']);
      } catch (Exception $e) {
        return false;
      }
      
      $twitterTweets = new Doctrine_Collection('TwitterTweet');
      foreach ($recievedTweets as $recievedTweet) {
        if ( $excludeId && $excludeId == $recievedTweet->id ) {
          continue;
        }
        $tweet = new TwitterTweet();
        $tweet->fromStdClass($recievedTweet);
        $tweet->setRaw(json_encode($recievedTweet));
        $twitterTweets->add($tweet);
      }
      $count = $twitterTweets->count();
      
      if ( $count ) {
        $twitterTweets->save();
      }
      
      $last_fetch_table->updateLastFetchTimeForClient(self::CLIENT_NAME, 'TwitterTweet', $query_sha1, $count);
      
      return $count;
    }
    
    return false;
  }

  /**
   * Send a tweet message with the API and save the TwitterTweet object
   * 
   * @param string $message
   * @param StatusUpdate $statusUpdate
   * @return TwitterTweet if the message is send and saved succesfully, if not send and saved the error is thrown
   */
  public function send($message, StatusUpdate $statusUpdate = null)
  {
    // get client
    $client = new Twitter();
    
    if ( !$client->isConnected() ) {
      throw new Exception(sprintf('Not connected to Twitter in %s.', __CLASS__));
    }
    
    // send message with the API
    $response = $client->post('statuses/update.json', array(
      'status' => $message
    )//'trim_user' => true, // omit user object from return
    );
    
    // process response
    $data = json_decode($response['body']);
    
    if ( $data instanceof stdClass && isset($data->id_str) ) {
      // create TwitterTweet
      $tweet = new TwitterTweet();
      $tweet->fromStdClass($data);
      $tweet->setRaw($response['body']);
      $tweet->setStatusUpdate($statusUpdate);
      $tweet->save();
      
      // sync tweets, this makes sure that messages send from outside the cms are cached in the database  
      // the sync always checks the latest inserted tweet, exclude the just created tweet
      $this->sync(0, $tweet->getTweetId());
      
      return $tweet;
    } elseif ( $data instanceof stdClass && isset($data->error) ) {
      throw new Exception(sprintf('Error received from API in %s: %s', __CLASS__, $data->error));
    } else {
      throw new Exception(sprintf('Cannot process API response in %s', __CLASS__));
    }
  }
}